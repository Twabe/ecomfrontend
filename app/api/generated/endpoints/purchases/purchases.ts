/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * .NET 7 WebAPI - Clean Architecture
 * Clean Architecture Template for .NET 7 WebApi built with Multitenancy Support.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/vue-query';
import type {
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType
} from '@tanstack/vue-query';

import {
  computed,
  unref
} from 'vue';
import type {
  MaybeRef
} from 'vue';

import type {
  CreatePurchaseRequest,
  ErrorResult,
  HttpValidationProblemDetails,
  PaginationResponseOfPurchaseDto,
  PurchaseDto,
  PurchaseHistoryDto,
  ReceivePurchaseRequest,
  SearchPurchasesRequest,
  UpdatePurchaseRequest
} from '../../models';

import { customInstance } from '../../../axios-instance';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Search purchases using available filters.
 */
export const purchasesSearch = (
    searchPurchasesRequest: MaybeRef<SearchPurchasesRequest>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      searchPurchasesRequest = unref(searchPurchasesRequest);
      
      return customInstance<PaginationResponseOfPurchaseDto>(
      {url: `/api/v1/purchases/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: searchPurchasesRequest, signal
    },
      options);
    }
  


export const getPurchasesSearchMutationOptions = <TError = HttpValidationProblemDetails | ErrorResult,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof purchasesSearch>>, TError,{data: SearchPurchasesRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof purchasesSearch>>, TError,{data: SearchPurchasesRequest}, TContext> => {

const mutationKey = ['purchasesSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof purchasesSearch>>, {data: SearchPurchasesRequest}> = (props) => {
          const {data} = props ?? {};

          return  purchasesSearch(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PurchasesSearchMutationResult = NonNullable<Awaited<ReturnType<typeof purchasesSearch>>>
    export type PurchasesSearchMutationBody = SearchPurchasesRequest
    export type PurchasesSearchMutationError = HttpValidationProblemDetails | ErrorResult

    /**
 * @summary Search purchases using available filters.
 */
export const usePurchasesSearch = <TError = HttpValidationProblemDetails | ErrorResult,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof purchasesSearch>>, TError,{data: SearchPurchasesRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof purchasesSearch>>,
        TError,
        {data: SearchPurchasesRequest},
        TContext
      > => {

      const mutationOptions = getPurchasesSearchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Get purchase details.
 */
export const purchasesGet = (
    id: MaybeRef<string>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      id = unref(id);
      
      return customInstance<PurchaseDto>(
      {url: `/api/v1/purchases/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getPurchasesGetQueryKey = (id?: MaybeRef<string>,) => {
    return [
    'api','v1','purchases',id
    ] as const;
    }

    
export const getPurchasesGetQueryOptions = <TData = Awaited<ReturnType<typeof purchasesGet>>, TError = HttpValidationProblemDetails | ErrorResult>(id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof purchasesGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  getPurchasesGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof purchasesGet>>> = ({ signal }) => purchasesGet(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(id))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof purchasesGet>>, TError, TData> 
}

export type PurchasesGetQueryResult = NonNullable<Awaited<ReturnType<typeof purchasesGet>>>
export type PurchasesGetQueryError = HttpValidationProblemDetails | ErrorResult


/**
 * @summary Get purchase details.
 */

export function usePurchasesGet<TData = Awaited<ReturnType<typeof purchasesGet>>, TError = HttpValidationProblemDetails | ErrorResult>(
 id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof purchasesGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPurchasesGetQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}



/**
 * @summary Update a purchase.
 */
export const purchasesUpdate = (
    id: MaybeRef<string>,
    updatePurchaseRequest: MaybeRef<UpdatePurchaseRequest>,
 options?: SecondParameter<typeof customInstance>,) => {
      id = unref(id);
updatePurchaseRequest = unref(updatePurchaseRequest);
      
      return customInstance<string>(
      {url: `/api/v1/purchases/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updatePurchaseRequest
    },
      options);
    }
  


export const getPurchasesUpdateMutationOptions = <TError = HttpValidationProblemDetails | ErrorResult,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof purchasesUpdate>>, TError,{id: string;data: UpdatePurchaseRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof purchasesUpdate>>, TError,{id: string;data: UpdatePurchaseRequest}, TContext> => {

const mutationKey = ['purchasesUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof purchasesUpdate>>, {id: string;data: UpdatePurchaseRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  purchasesUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PurchasesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof purchasesUpdate>>>
    export type PurchasesUpdateMutationBody = UpdatePurchaseRequest
    export type PurchasesUpdateMutationError = HttpValidationProblemDetails | ErrorResult

    /**
 * @summary Update a purchase.
 */
export const usePurchasesUpdate = <TError = HttpValidationProblemDetails | ErrorResult,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof purchasesUpdate>>, TError,{id: string;data: UpdatePurchaseRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof purchasesUpdate>>,
        TError,
        {id: string;data: UpdatePurchaseRequest},
        TContext
      > => {

      const mutationOptions = getPurchasesUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Delete a purchase.
 */
export const purchasesDelete = (
    id: MaybeRef<string>,
 options?: SecondParameter<typeof customInstance>,) => {
      id = unref(id);
      
      return customInstance<string>(
      {url: `/api/v1/purchases/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getPurchasesDeleteMutationOptions = <TError = HttpValidationProblemDetails | ErrorResult,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof purchasesDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof purchasesDelete>>, TError,{id: string}, TContext> => {

const mutationKey = ['purchasesDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof purchasesDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  purchasesDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PurchasesDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof purchasesDelete>>>
    
    export type PurchasesDeleteMutationError = HttpValidationProblemDetails | ErrorResult

    /**
 * @summary Delete a purchase.
 */
export const usePurchasesDelete = <TError = HttpValidationProblemDetails | ErrorResult,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof purchasesDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof purchasesDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getPurchasesDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Create a new purchase.
 */
export const purchasesCreate = (
    createPurchaseRequest: MaybeRef<CreatePurchaseRequest>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      createPurchaseRequest = unref(createPurchaseRequest);
      
      return customInstance<string>(
      {url: `/api/v1/purchases`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createPurchaseRequest, signal
    },
      options);
    }
  


export const getPurchasesCreateMutationOptions = <TError = HttpValidationProblemDetails | ErrorResult,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof purchasesCreate>>, TError,{data: CreatePurchaseRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof purchasesCreate>>, TError,{data: CreatePurchaseRequest}, TContext> => {

const mutationKey = ['purchasesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof purchasesCreate>>, {data: CreatePurchaseRequest}> = (props) => {
          const {data} = props ?? {};

          return  purchasesCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PurchasesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof purchasesCreate>>>
    export type PurchasesCreateMutationBody = CreatePurchaseRequest
    export type PurchasesCreateMutationError = HttpValidationProblemDetails | ErrorResult

    /**
 * @summary Create a new purchase.
 */
export const usePurchasesCreate = <TError = HttpValidationProblemDetails | ErrorResult,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof purchasesCreate>>, TError,{data: CreatePurchaseRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof purchasesCreate>>,
        TError,
        {data: CreatePurchaseRequest},
        TContext
      > => {

      const mutationOptions = getPurchasesCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Receive a purchase and update stock with Weighted Average costing.
 */
export const purchasesReceive = (
    id: MaybeRef<string>,
    receivePurchaseRequest: MaybeRef<ReceivePurchaseRequest>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      id = unref(id);
receivePurchaseRequest = unref(receivePurchaseRequest);
      
      return customInstance<string>(
      {url: `/api/v1/purchases/${id}/receive`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: receivePurchaseRequest, signal
    },
      options);
    }
  


export const getPurchasesReceiveMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof purchasesReceive>>, TError,{id: string;data: ReceivePurchaseRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof purchasesReceive>>, TError,{id: string;data: ReceivePurchaseRequest}, TContext> => {

const mutationKey = ['purchasesReceive'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof purchasesReceive>>, {id: string;data: ReceivePurchaseRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  purchasesReceive(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PurchasesReceiveMutationResult = NonNullable<Awaited<ReturnType<typeof purchasesReceive>>>
    export type PurchasesReceiveMutationBody = ReceivePurchaseRequest
    export type PurchasesReceiveMutationError = unknown

    /**
 * @summary Receive a purchase and update stock with Weighted Average costing.
 */
export const usePurchasesReceive = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof purchasesReceive>>, TError,{id: string;data: ReceivePurchaseRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof purchasesReceive>>,
        TError,
        {id: string;data: ReceivePurchaseRequest},
        TContext
      > => {

      const mutationOptions = getPurchasesReceiveMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Get purchase status change history.
 */
export const purchasesGetHistory = (
    id: MaybeRef<string>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      id = unref(id);
      
      return customInstance<PurchaseHistoryDto[]>(
      {url: `/api/v1/purchases/${id}/history`, method: 'GET', signal
    },
      options);
    }
  



export const getPurchasesGetHistoryQueryKey = (id?: MaybeRef<string>,) => {
    return [
    'api','v1','purchases',id,'history'
    ] as const;
    }

    
export const getPurchasesGetHistoryQueryOptions = <TData = Awaited<ReturnType<typeof purchasesGetHistory>>, TError = HttpValidationProblemDetails | ErrorResult>(id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof purchasesGetHistory>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  getPurchasesGetHistoryQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof purchasesGetHistory>>> = ({ signal }) => purchasesGetHistory(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(id))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof purchasesGetHistory>>, TError, TData> 
}

export type PurchasesGetHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof purchasesGetHistory>>>
export type PurchasesGetHistoryQueryError = HttpValidationProblemDetails | ErrorResult


/**
 * @summary Get purchase status change history.
 */

export function usePurchasesGetHistory<TData = Awaited<ReturnType<typeof purchasesGetHistory>>, TError = HttpValidationProblemDetails | ErrorResult>(
 id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof purchasesGetHistory>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPurchasesGetHistoryQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}



